
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Algebra &#8212; liesym 0.1.0 documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Groups" href="group.html" />
    <link rel="prev" title="Welcome to liesym’s documentation!" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="index.html">
<p class="title">liesym</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Algebra
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="group.html">
  Groups
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lie-algebra-base">
   Lie Algebra Base
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-series">
   A Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#b-series">
   B Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c-series">
   C Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#d-series">
   D Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#e-series">
   E Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#g2-series">
   G2 Series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#f4-series">
   F4 Series
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="algebra">
<h1>Algebra<a class="headerlink" href="#algebra" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lie-algebra-base">
<h2>Lie Algebra Base<a class="headerlink" href="#lie-algebra-base" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.LieAlgebra">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">LieAlgebra</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for all lie algebras. The methods and properties
in this class are basis independent and apply in a general sense. In
order to write down the roots as matricies and vectors, we choose a 
representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.LieAlgebra.cartan_matrix" title="liesym.LieAlgebra.cartan_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cartan_matrix</span></code></a></dt><dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.cocartan_matrix" title="liesym.LieAlgebra.cocartan_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cocartan_matrix</span></code></a></dt><dd><p>The cocartan matrix rows are generated from the coroots of the algebra such that multiplication by a simple root will generate a row of the cartan matrix.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.dimension" title="liesym.LieAlgebra.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>Algebra dimension</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.fundamental_weights" title="liesym.LieAlgebra.fundamental_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fundamental_weights</span></code></a></dt><dd><p>Returns the fundamental weights of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.metric_tensor" title="liesym.LieAlgebra.metric_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metric_tensor</span></code></a></dt><dd><p>Also known as the quadratic form, the metric tensor serves as the metrix for the inner product of two roots or weights when they are not in the orthogonal basis.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.n_pos_roots" title="liesym.LieAlgebra.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>Total number of positive roots in the algebra</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.n_roots" title="liesym.LieAlgebra.n_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_roots</span></code></a></dt><dd><p>Total number of roots in the algebra</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.omega_matrix" title="liesym.LieAlgebra.omega_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">omega_matrix</span></code></a></dt><dd><p>The rows of the omega matrix are the fundamental weights of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.positive_roots" title="liesym.LieAlgebra.positive_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">positive_roots</span></code></a></dt><dd><p>Returns the postive roots of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.rank" title="liesym.LieAlgebra.rank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rank</span></code></a></dt><dd><p>Algebra rank</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.reflection_matricies" title="liesym.LieAlgebra.reflection_matricies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reflection_matricies</span></code></a></dt><dd><p>Returns a list of reflection matrices built from rotations about each simple root.</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.series" title="liesym.LieAlgebra.series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">series</span></code></a></dt><dd><p>Algebra series type</p>
</dd>
<dt><a class="reference internal" href="#liesym.LieAlgebra.simple_roots" title="liesym.LieAlgebra.simple_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">simple_roots</span></code></a></dt><dd><p>Returns a list of Sympy matrix (1,dimension) objects representing a chosen basis of the algebra.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.conjugate" title="liesym.LieAlgebra.conjugate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code></a>(irrep)</p></td>
<td><p>Finds the conjugate irrep.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.dim" title="liesym.LieAlgebra.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>(irrep[, basis])</p></td>
<td><p>Returns the dimension of the weight, root or irreducible representations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.dim_name" title="liesym.LieAlgebra.dim_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim_name</span></code></a>(irrep[, basis])</p></td>
<td><p>Returns a sympy formatted symbol for the irrep.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.get_irrep_by_dim" title="liesym.LieAlgebra.get_irrep_by_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_irrep_by_dim</span></code></a>(dim[, max_dd, with_symbols])</p></td>
<td><p>Gets all irreps by dimension and max dynkin digit.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.irrep_lookup" title="liesym.LieAlgebra.irrep_lookup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irrep_lookup</span></code></a>(dim)</p></td>
<td><p>Returns the irrep matrix for the dimension.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.max_dynkin_digit" title="liesym.LieAlgebra.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representations</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.orbit" title="liesym.LieAlgebra.orbit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbit</span></code></a>(weight[, stabilizers, basis])</p></td>
<td><p>Returns the orbit of the weight or root by reflecting it a plane.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.root_system" title="liesym.LieAlgebra.root_system"><code class="xref py py-obj docutils literal notranslate"><span class="pre">root_system</span></code></a>()</p></td>
<td><p>Returns the entire rootsystem of the algebra.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.tensor_product_decomposition" title="liesym.LieAlgebra.tensor_product_decomposition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_product_decomposition</span></code></a>(weights[, basis])</p></td>
<td><p>Returns the tensor product between irreducible representations as a the tensor sum of the irreducible representations of their highest weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.to_alpha" title="liesym.LieAlgebra.to_alpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_alpha</span></code></a>(x[, basis])</p></td>
<td><p>Rotates to alpha basis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.LieAlgebra.to_omega" title="liesym.LieAlgebra.to_omega"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_omega</span></code></a>(x[, basis])</p></td>
<td><p>Rotates to omega basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.LieAlgebra.to_ortho" title="liesym.LieAlgebra.to_ortho"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_ortho</span></code></a>(x[, basis])</p></td>
<td><p>Rotates to orthogonal basis</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.LieAlgebra.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.LieAlgebra.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.LieAlgebra.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.dim_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.LieAlgebra.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra dimension</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.LieAlgebra.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.get_irrep_by_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.irrep_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representations</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.LieAlgebra.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.LieAlgebra.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of positive roots in the algebra</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.LieAlgebra.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.LieAlgebra.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.orbit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.LieAlgebra.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.LieAlgebra.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.LieAlgebra.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.root_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.LieAlgebra.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.LieAlgebra.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.tensor_product_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.to_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.to_omega"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.LieAlgebra.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="reference internal" href="_modules/liesym/algebras/_base.html#LieAlgebra.to_ortho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.LieAlgebra.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="a-series">
<h2>A Series<a class="headerlink" href="#a-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.A">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">A</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_classic.html#A"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.A" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type A. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_A.png"><img alt="_images/type_A.png" class="align-center" src="_images/type_A.png" style="width: 300px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.A.dimension" title="liesym.A.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>The dimension of the simple Lie algebra A series is one greater than the rank of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.A.n_pos_roots" title="liesym.A.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>The number of positive roots for the simple Lie algebra A is</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.A.dim_name" title="liesym.A.dim_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim_name</span></code></a>(irrep[, basis])</p></td>
<td><p>Returns a sympy formatted symbol for the irrep.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#liesym.A.max_dynkin_digit" title="liesym.A.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.A.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.A.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.A.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.A.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.A.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.A.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.A.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.A.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="reference internal" href="_modules/liesym/algebras/_classic.html#A.dim_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.A.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.A.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the simple Lie algebra A series is
one greater than the rank of the algebra.</p>
<div class="math notranslate nohighlight">
\[n + 1\]</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.A.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.A.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.A.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.A.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.A.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.A.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.A.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.A.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.A.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.A.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.A.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.A.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.A.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.A.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.A.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.A.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.A.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.A.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.A.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.A.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.A.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.A.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.A.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.A.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.A.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.A.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.A.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.A.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.A.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.A.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.A.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.A.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.A.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.A.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.A.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.A.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.A.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.A.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.A.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.A.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.A.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.A.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_classic.html#A.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.A.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.A.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.A.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of positive roots for the simple Lie algebra A is 
defined as</p>
<div class="math notranslate nohighlight">
\[n(n + 1) / 2\]</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.A.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.A.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.A.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.A.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.A.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.A.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.A.subs" title="liesym.A.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.A.xreplace" title="liesym.A.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.A.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.A.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.A.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.A.replace" title="liesym.A.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.A.xreplace" title="liesym.A.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.A.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.A.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.A.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.A.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.A.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.A.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.A.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.A.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.A.replace" title="liesym.A.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.A.subs" title="liesym.A.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="b-series">
<h2>B Series<a class="headerlink" href="#b-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.B">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">B</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_classic.html#B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.B" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type B. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_B.png"><img alt="_images/type_B.png" class="align-center" src="_images/type_B.png" style="width: 300px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.B.dimension" title="liesym.B.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>The dimension of the simple Lie algebra B series is equal to the rank of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.B.n_pos_roots" title="liesym.B.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>The number of positive roots for the simple Lie algebra B is</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.B.max_dynkin_digit" title="liesym.B.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.B.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.B.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.B.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.B.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.B.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.B.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.B.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.B.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.B.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.B.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the simple Lie algebra B series is
equal to the rank of the algebra.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.B.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.B.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.B.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.B.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.B.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.B.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.B.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.B.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.B.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.B.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.B.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.B.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.B.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.B.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.B.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.B.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.B.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.B.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.B.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.B.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.B.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.B.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.B.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.B.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.B.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.B.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.B.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.B.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.B.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.B.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.B.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.B.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.B.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.B.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.B.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.B.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.B.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.B.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.B.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.B.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.B.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.B.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_classic.html#B.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.B.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.B.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.B.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of positive roots for the simple Lie algebra B is 
defined as</p>
<div class="math notranslate nohighlight">
\[n^2\]</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.B.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.B.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.B.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.B.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.B.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.B.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.B.subs" title="liesym.B.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.B.xreplace" title="liesym.B.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.B.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.B.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.B.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.B.replace" title="liesym.B.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.B.xreplace" title="liesym.B.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.B.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.B.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.B.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.B.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.B.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.B.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.B.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.B.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.B.replace" title="liesym.B.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.B.subs" title="liesym.B.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="c-series">
<h2>C Series<a class="headerlink" href="#c-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.C">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">C</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_classic.html#C"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.C" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type C. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_C.png"><img alt="_images/type_C.png" class="align-center" src="_images/type_C.png" style="width: 300px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.C.dimension" title="liesym.C.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>The dimension of the simple Lie algebra C series is equal to the rank of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.C.n_pos_roots" title="liesym.C.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>The number of positive roots for the simple Lie algebra C is</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.C.max_dynkin_digit" title="liesym.C.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.C.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.C.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.C.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.C.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.C.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.C.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.C.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.C.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.C.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.C.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the simple Lie algebra C series is
equal to the rank of the algebra.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.C.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.C.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.C.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.C.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.C.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.C.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.C.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.C.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.C.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.C.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.C.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.C.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.C.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.C.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.C.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.C.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.C.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.C.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.C.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.C.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.C.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.C.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.C.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.C.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.C.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.C.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.C.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.C.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.C.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.C.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.C.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.C.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.C.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.C.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.C.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.C.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.C.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.C.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.C.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.C.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.C.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.C.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_classic.html#C.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.C.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.C.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.C.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of positive roots for the simple Lie algebra C is 
defined as</p>
<div class="math notranslate nohighlight">
\[n^2\]</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.C.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.C.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.C.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.C.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.C.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.C.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.C.subs" title="liesym.C.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.C.xreplace" title="liesym.C.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.C.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.C.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.C.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.C.replace" title="liesym.C.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.C.xreplace" title="liesym.C.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.C.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.C.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.C.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.C.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.C.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.C.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.C.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.C.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.C.replace" title="liesym.C.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.C.subs" title="liesym.C.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="d-series">
<h2>D Series<a class="headerlink" href="#d-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.D">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">D</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_classic.html#D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.D" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type D. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_D.png"><img alt="_images/type_D.png" class="align-center" src="_images/type_D.png" style="width: 300px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.D.dimension" title="liesym.D.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>The dimension of the simple Lie algebra D series is equal to the rank of the algebra.</p>
</dd>
<dt><a class="reference internal" href="#liesym.D.n_pos_roots" title="liesym.D.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>The number of roots for the simple Lie algebra D is</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.D.max_dynkin_digit" title="liesym.D.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.D.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.D.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.D.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.D.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.D.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.D.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.D.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.D.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.D.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the simple Lie algebra D series is
equal to the rank of the algebra.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.D.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.D.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.D.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.D.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.D.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.D.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.D.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.D.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.D.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.D.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.D.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.D.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.D.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.D.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.D.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.D.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.D.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.D.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.D.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.D.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.D.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.D.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.D.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.D.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.D.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.D.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.D.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.D.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.D.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.D.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.D.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.D.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.D.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.D.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.D.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.D.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.D.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.D.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.D.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.D.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.D.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.D.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_classic.html#D.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.D.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.D.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.D.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of roots for the simple Lie algebra D is 
defined as</p>
<div class="math notranslate nohighlight">
\[n(n-1)\]</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.D.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.D.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.D.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.D.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.D.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.D.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.D.subs" title="liesym.D.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.D.xreplace" title="liesym.D.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.D.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.D.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.D.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.D.replace" title="liesym.D.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.D.xreplace" title="liesym.D.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.D.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.D.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.D.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.D.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.D.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.D.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.D.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.D.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.D.replace" title="liesym.D.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.D.subs" title="liesym.D.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="e-series">
<h2>E Series<a class="headerlink" href="#e-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.E">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">E</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.E" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type E. There are only three defined for
type E.</p>
<blockquote>
<div><div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/type_E6.png"><img alt="_images/type_E6.png" src="_images/type_E6.png" style="height: 100px;" /></a>
<p class="caption"><span class="caption-text">E6</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="_images/type_E7.png"><img alt="_images/type_E7.png" src="_images/type_E7.png" style="height: 100px;" /></a>
<p class="caption"><span class="caption-text">E7</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="_images/type_E8.png"><img alt="_images/type_E8.png" src="_images/type_E8.png" style="height: 100px;" /></a>
<p class="caption"><span class="caption-text">E8</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.E.dimension" title="liesym.E.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>Algebra dimension</p>
</dd>
<dt><a class="reference internal" href="#liesym.E.n_pos_roots" title="liesym.E.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>Total number of positive roots in the algebra</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.E.max_dynkin_digit" title="liesym.E.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.E.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.E.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.E.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.E.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.E.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.E.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.E.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.E.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.E.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.E.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra dimension</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.E.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.E.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.E.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.E.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.E.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.E.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.E.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.E.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.E.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.E.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.E.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.E.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.E.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.E.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.E.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.E.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.E.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.E.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.E.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.E.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.E.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.E.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.E.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.E.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.E.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.E.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.E.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.E.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.E.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.E.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.E.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.E.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.E.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.E.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.E.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.E.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.E.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.E.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.E.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.E.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.E.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.E.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#E.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.E.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.E.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.E.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of positive roots in the algebra</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.E.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.E.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.E.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.E.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.E.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.E.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.E.subs" title="liesym.E.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.E.xreplace" title="liesym.E.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.E.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.E.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.E.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.E.replace" title="liesym.E.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.E.xreplace" title="liesym.E.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.E.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.E.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.E.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.E.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.E.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.E.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.E.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.E.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.E.replace" title="liesym.E.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.E.subs" title="liesym.E.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="g2-series">
<h2>G2 Series<a class="headerlink" href="#g2-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.G2">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">G2</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#G2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.G2" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type G2. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_G2.png"><img alt="_images/type_G2.png" class="align-center" src="_images/type_G2.png" style="height: 50px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.G2.dimension" title="liesym.G2.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>Algebra dimension</p>
</dd>
<dt><a class="reference internal" href="#liesym.G2.n_pos_roots" title="liesym.G2.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>Total number of positive roots in the algebra</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.G2.max_dynkin_digit" title="liesym.G2.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.G2.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.G2.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.G2.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.G2.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.G2.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.G2.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.G2.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.G2.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.G2.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.G2.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra dimension</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.G2.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.G2.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.G2.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.G2.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.G2.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.G2.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.G2.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.G2.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.G2.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.G2.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.G2.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.G2.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.G2.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.G2.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.G2.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.G2.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.G2.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.G2.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.G2.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.G2.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.G2.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.G2.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.G2.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.G2.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.G2.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.G2.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.G2.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.G2.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.G2.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.G2.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.G2.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.G2.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.G2.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.G2.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.G2.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.G2.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.G2.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.G2.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.G2.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.G2.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.G2.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.G2.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#G2.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.G2.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.G2.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.G2.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of positive roots in the algebra</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.G2.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.G2.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.G2.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.G2.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.G2.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.G2.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.G2.subs" title="liesym.G2.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.G2.xreplace" title="liesym.G2.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.G2.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.G2.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.G2.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.G2.replace" title="liesym.G2.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.G2.xreplace" title="liesym.G2.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.G2.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.G2.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.G2.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.G2.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.G2.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.G2.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.G2.replace" title="liesym.G2.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.G2.subs" title="liesym.G2.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="f4-series">
<h2>F4 Series<a class="headerlink" href="#f4-series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="liesym.F4">
<em class="property">class </em><code class="sig-prename descclassname">liesym.</code><code class="sig-name descname">F4</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#F4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.F4" title="Permalink to this definition">¶</a></dt>
<dd><p>The compact lie group of type F4. The dynkin diagram for this algebra is</p>
<a class="reference internal image-reference" href="_images/type_F4.png"><img alt="_images/type_F4.png" class="align-center" src="_images/type_F4.png" style="height: 50px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#liesym.F4.dimension" title="liesym.F4.dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimension</span></code></a></dt><dd><p>Algebra dimension</p>
</dd>
<dt><a class="reference internal" href="#liesym.F4.n_pos_roots" title="liesym.F4.n_pos_roots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pos_roots</span></code></a></dt><dd><p>Total number of positive roots in the algebra</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#liesym.F4.max_dynkin_digit" title="liesym.F4.max_dynkin_digit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_dynkin_digit</span></code></a>(irrep)</p></td>
<td><p>Returns the max Dynkin Digit for the representation</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="liesym.F4.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#liesym.F4.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>A stub to allow Basic args (like Tuple) to be skipped when computing
the content and primitive components of an expression.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.expr.Expr.as_content_primitive</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<p class="rubric">Notes</p>
<p>Any object that has structurally bound variables should have
a property, <cite>bound_symbols</cite> that returns those symbols
appearing in the object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">_r</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#liesym.F4.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended_negative&#39;: False,</span>
<span class="go"> &#39;extended_nonnegative&#39;: True, &#39;extended_nonpositive&#39;: False,</span>
<span class="go"> &#39;extended_nonzero&#39;: True, &#39;extended_positive&#39;: True, &#39;extended_real&#39;:</span>
<span class="go"> True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="go"> &#39;infinite&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go"> &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;:</span>
<span class="go"> True, &#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#liesym.F4.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any free symbols in the expression.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.cartan_matrix">
<em class="property">property </em><code class="sig-name descname">cartan_matrix</code><a class="headerlink" href="#liesym.F4.cartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given simple Lie algebra the elements <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be
generated by</p>
<div class="math notranslate nohighlight">
\[a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the i’th simple root and <span class="math notranslate nohighlight">\(\langle,\rangle\)</span> is the scalar product.</p>
<dl class="simple">
<dt>Sources:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cartan_matrix">https://en.wikipedia.org/wiki/Cartan_matrix</a></p></li>
<li><p><a class="reference external" href="https://mathworld.wolfram.com/CartanMatrix.html">https://mathworld.wolfram.com/CartanMatrix.html</a></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Cartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.cocartan_matrix">
<em class="property">property </em><code class="sig-name descname">cocartan_matrix</code><a class="headerlink" href="#liesym.F4.cocartan_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The cocartan matrix rows are generated from the coroots of 
the algebra such that multiplication by a simple root will
generate a row of the cartan matrix.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Cocartan Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.F4.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the conjugate irrep. If it is the same
as the original irrep, you have a Real Irrep, otherwise
it’s a Complex Irrep.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span><span class="n">D</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>

<span class="n">SU4</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">irrep_20</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">irrep_20bar</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_20</span> <span class="o">==</span> <span class="n">SU4</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_20bar</span><span class="p">)</span>

<span class="n">SO10</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">irrep_10</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="k">assert</span> <span class="n">irrep_10</span> <span class="o">==</span> <span class="n">SO10</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">irrep_10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.dim">
<code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#liesym.F4.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dimension of the weight, root or irreducible representations.
This follows Weyl’s dimension formula:</p>
<div class="math notranslate nohighlight">
\[dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta^{+}\)</span> are the positive roots and <span class="math notranslate nohighlight">\(rho\)</span> is the sum of
the positive roots: <cite>[1] * rank</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span> <span class="c1"># fundamental rep</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.dim_name">
<code class="sig-name descname">dim_name</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis='omega'</em><span class="sig-paren">)</span> &#x2192; liesym.algebras._base.NumericSymbol<a class="headerlink" href="#liesym.F4.dim_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy formatted symbol for the irrep.
This is commonly used in physics literature. Returns
a NumericSymbol object that is a simple extension of 
sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">dim_name</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="go">\bar{20}       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#liesym.F4.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra dimension</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#liesym.F4.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#liesym.F4.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#liesym.F4.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.fundamental_weights">
<em class="property">property </em><code class="sig-name descname">fundamental_weights</code><a class="headerlink" href="#liesym.F4.fundamental_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fundamental weights of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.get_irrep_by_dim">
<code class="sig-name descname">get_irrep_by_dim</code><span class="sig-paren">(</span><em class="sig-param">dim: int</em>, <em class="sig-param">max_dd: int = 3</em>, <em class="sig-param">with_symbols=False</em><span class="sig-paren">)</span> &#x2192; List[Union[sympy.matrices.dense.MutableDenseMatrix, Tuple[sympy.matrices.dense.MutableDenseMatrix, liesym.algebras._base.NumericSymbol]]]<a class="headerlink" href="#liesym.F4.get_irrep_by_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all irreps by dimension and max dynkin digit. <cite>max_dd</cite> is . This algorithm brute forces searches by using <cite>itertools.product</cite>
which can become expensive for large so searching max_dd &gt; 3 will be 
very expensive</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (int): Dimension to query
max_dd (int, optional): The max dynkin digit to use. Defaults to 3.
with_symbols (bool, optional): Returns list of tuples of rep and latex fmt. Defaults to False.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Union[Matrix, Tuple[Matrix,NumericSymbol]]]: If <cite>with_symbols=True</cite> will return a list of tuples.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[Matrix([[1, 1, 0]]),</span>
<span class="go"> Matrix([[0, 1, 1]]),</span>
<span class="go"> Matrix([[0, 2, 0]]),</span>
<span class="go"> Matrix([[3, 0, 0]]),</span>
<span class="go"> Matrix([[0, 0, 3]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span><span class="o">.</span><span class="n">get_irrep_by_dim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">with_symbols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Matrix([[1, 1, 0]]), &#39;\bar{20}&#39;),</span>
<span class="go"> (Matrix([[0, 1, 1]]), &#39;20&#39;),</span>
<span class="go"> (Matrix([[0, 2, 0]]), &#39;20^{\prime}&#39;),</span>
<span class="go"> (Matrix([[3, 0, 0]]), &#39;\bar{20}^{\prime \prime}&#39;),</span>
<span class="go"> (Matrix([[0, 0, 3]]), &#39;20^{\prime \prime}&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.has">
<code class="sig-name descname">has</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.irrep_lookup">
<code class="sig-name descname">irrep_lookup</code><span class="sig-paren">(</span><em class="sig-param">dim: Union[sympy.core.symbol.Symbol, str]</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.F4.irrep_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the irrep matrix for the dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim (Union[Symbol, str]): Can either be a sympy.Symbol or string.</p>
</dd>
<dt>Raises:</dt><dd><p>KeyError: Dim not found</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Returns irrep in Omega basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ar</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Matrix([[0,0,1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A3</span><span class="o">.</span><span class="n">irrep_lookup</span><span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
<span class="go">Matrix([[1,0,0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#liesym.F4.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#liesym.F4.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#liesym.F4.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_comparable">
<em class="property">property </em><code class="sig-name descname">is_comparable</code><a class="headerlink" href="#liesym.F4.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self can be computed to a real number
(or already is a real number) with precision, else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A False result does not mean that <cite>self</cite> cannot be rewritten
into a form that would be comparable. For example, the
difference computed below is zero but without simplification
it does not evaluate to a zero with precision:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dif</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_prec</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#liesym.F4.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#liesym.F4.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#liesym.F4.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_negative">
<em class="property">property </em><code class="sig-name descname">is_extended_negative</code><a class="headerlink" href="#liesym.F4.is_extended_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_extended_nonnegative</code><a class="headerlink" href="#liesym.F4.is_extended_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_extended_nonpositive</code><a class="headerlink" href="#liesym.F4.is_extended_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_nonzero">
<em class="property">property </em><code class="sig-name descname">is_extended_nonzero</code><a class="headerlink" href="#liesym.F4.is_extended_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_positive">
<em class="property">property </em><code class="sig-name descname">is_extended_positive</code><a class="headerlink" href="#liesym.F4.is_extended_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_extended_real">
<em class="property">property </em><code class="sig-name descname">is_extended_real</code><a class="headerlink" href="#liesym.F4.is_extended_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#liesym.F4.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#liesym.F4.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#liesym.F4.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#liesym.F4.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#liesym.F4.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#liesym.F4.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#liesym.F4.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#liesym.F4.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#liesym.F4.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#liesym.F4.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#liesym.F4.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#liesym.F4.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#liesym.F4.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#liesym.F4.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#liesym.F4.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#liesym.F4.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#liesym.F4.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = False</em><a class="headerlink" href="#liesym.F4.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#liesym.F4.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#liesym.F4.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="liesym.F4.kind">
<code class="sig-name descname">kind</code><em class="property"> = UndefinedKind</em><a class="headerlink" href="#liesym.F4.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="liesym.F4.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>Structurally bound symbols are ignored during matching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2}</span>
</pre></div>
</div>
<p>But they can be identified if desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="go">{p_: 2, q_: x}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.max_dynkin_digit">
<code class="sig-name descname">max_dynkin_digit</code><span class="sig-paren">(</span><em class="sig-param">irrep: sympy.matrices.dense.MutableDenseMatrix</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/liesym/algebras/_exceptionals.html#F4.max_dynkin_digit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#liesym.F4.max_dynkin_digit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max Dynkin Digit for the representation</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.metric_tensor">
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#liesym.F4.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as the quadratic form, the metric tensor
serves as the metrix for the inner product of two roots or weights
when they are not in the orthogonal basis.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Metric Tensor as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.n_pos_roots">
<em class="property">property </em><code class="sig-name descname">n_pos_roots</code><a class="headerlink" href="#liesym.F4.n_pos_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of positive roots in the algebra</p>
<p>Abstract</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.n_roots">
<em class="property">property </em><code class="sig-name descname">n_roots</code><a class="headerlink" href="#liesym.F4.n_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of roots in the algebra</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.omega_matrix">
<em class="property">property </em><code class="sig-name descname">omega_matrix</code><a class="headerlink" href="#liesym.F4.omega_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The rows of the omega matrix are the fundamental weights
of the algebra.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Matrix: Omega Matrix as a Sympy object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.orbit">
<code class="sig-name descname">orbit</code><span class="sig-paren">(</span><em class="sig-param">weight: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">stabilizers=None</em>, <em class="sig-param">basis='ortho'</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.F4.orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orbit of the weight or root by reflecting it
a plane. A stabilizer may be passed to calculate the orbit using
the Orbit-Stabilizer theorem.</p>
<p>Basis: Ortho</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weight (Matrix): A Matrix of shape (1, rank)
stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
theorem, integer iterable of simple root indexes. Defaults to None.</p>
</dd>
</dl>
<p>Sources:
- <a class="reference external" href="https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit">https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit</a>
- <a class="reference external" href="https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers">https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers</a></p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.positive_roots">
<em class="property">property </em><code class="sig-name descname">positive_roots</code><a class="headerlink" href="#liesym.F4.positive_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the postive roots of the algebra. They are sorted 
first by their distance from the highest root and then by 
tuple ordering (convention).</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.rank">
<em class="property">property </em><code class="sig-name descname">rank</code><a class="headerlink" href="#liesym.F4.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra rank</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.reflection_matricies">
<em class="property">property </em><code class="sig-name descname">reflection_matricies</code><a class="headerlink" href="#liesym.F4.reflection_matricies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of reflection matrices built from
rotations about each simple root.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of Sympy Matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.F4.subs" title="liesym.F4.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#liesym.F4.xreplace" title="liesym.F4.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
<p>When matching a single symbol, <cite>exact</cite> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <cite>exact=False</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">f(1) + f(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">f(0) + f(2)</span>
</pre></div>
</div>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(-x - y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">x</span><span class="o">**-</span><span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**(1 - y)</span>
</pre></div>
</div>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">x**(1 - y) + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.root_system">
<code class="sig-name descname">root_system</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.F4.root_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entire rootsystem of the algebra. This
includes the positive, negative and zeros of the algebra.</p>
<p>Basis: Orthogonal</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>List[Matrix]: List of ordered roots.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.series">
<em class="property">property </em><code class="sig-name descname">series</code><a class="headerlink" href="#liesym.F4.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra series type</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.simple_roots">
<em class="property">property </em><code class="sig-name descname">simple_roots</code><a class="headerlink" href="#liesym.F4.simple_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Sympy matrix (1,dimension)
objects representing a chosen basis of the algebra.</p>
<p>Basis: Orthogonal</p>
<p>This method can be overridden to choose your own basis,
be sure to do this before any other properties are called
as they are lazily evaluated and the simple_roots define
the entire representation of the algebra.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">F4</span>

<span class="n">algebra</span> <span class="o">=</span> <span class="n">F4</span><span class="p">()</span>
<span class="n">my_simple_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># my basis</span>
    <span class="p">]</span>
<span class="n">algebra</span><span class="o">.</span><span class="n">simple_roots</span> <span class="o">=</span> <span class="n">my_simple_roots</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.sort_key">
<code class="sig-name descname">sort_key</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sort key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[1/2, -I, I]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="s2">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class="p">)</span>
<span class="go">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
<span class="go">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.F4.replace" title="liesym.F4.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.F4.xreplace" title="liesym.F4.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.evalf.EvalfMixin.evalf</span></code></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.tensor_product_decomposition">
<code class="sig-name descname">tensor_product_decomposition</code><span class="sig-paren">(</span><em class="sig-param">weights: List[sympy.matrices.dense.MutableDenseMatrix], basis='omega', **_</em><span class="sig-paren">)</span> &#x2192; List[sympy.matrices.dense.MutableDenseMatrix]<a class="headerlink" href="#liesym.F4.tensor_product_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tensor product between irreducible representations
as a the tensor sum of the irreducible representations of their
highest weights. This algorithm is based on Klimky’s formula.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>weights (List[Matrix]): A list of fundamental weights to take the tensor product between
basis (str, Optional): Basis of incoming weights. If not set, will implicitly set. Defaults to ‘omega’.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Matrix]: List of weights decomposed from the tensor product. Basis: Omega</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">liesym</span> <span class="kn">import</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">tensor_product_decomposition</span><span class="p">([</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">[Matrix([[0, 1]]), Matrix([[2, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.to_alpha">
<code class="sig-name descname">to_alpha</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.F4.to_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to alpha basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in alpha basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.to_omega">
<code class="sig-name descname">to_omega</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.F4.to_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to omega basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in omega basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.to_ortho">
<code class="sig-name descname">to_ortho</code><span class="sig-paren">(</span><em class="sig-param">x: sympy.matrices.dense.MutableDenseMatrix</em>, <em class="sig-param">basis=None</em><span class="sig-paren">)</span> &#x2192; sympy.matrices.dense.MutableDenseMatrix<a class="headerlink" href="#liesym.F4.to_ortho" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates to orthogonal basis</p>
<dl class="simple">
<dt>Args:</dt><dd><p>x (Matrix): Matrix to be rotated
basis (optional): If <cite>basis</cite> attribute is not set on <cite>x</cite> define it here. Defaults to None.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If no <cite>x.basis</cite> is set and None is passed to <cite>basis</cite> kwarg.</p>
</dd>
<dt>Returns:</dt><dd><p>Matrix: Matrix in orthogonal basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="liesym.F4.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#liesym.F4.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">dict-like</span></dt><dd><p>Expresses a replacement rule</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xreplace</strong><span class="classifier">the result of the replacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#liesym.F4.replace" title="liesym.F4.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#liesym.F4.subs" title="liesym.F4.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="index.html" title="previous page">Welcome to liesym’s documentation!</a>
    <a class='right-next' id="next-link" href="group.html" title="next page">Groups</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, Nathan Papapietro.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>