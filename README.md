# liesym

Lie Algebras using Sympy and backend powered by Rust's pyO3 and ndarray

## Overview

In an effort to supply python with the same computer algebra software (CAS)
capabilities, [SymPy](https://github.com/sympy/sympy) was written. This python
library is well written and allows an open source alternative to proprietary
choices like Mathematica/WolframLanguage and Maple. Due to the nature of
how SymPy was written, certain symbolic calculation can be extremely unoptimized
in python. Even using numpy could offer little speed ups as it is not geared
towards rational numbers (fractions). Sympy does currently offer a `liealgebras`
module, but due to the performance limitations, certain tradeoffs had to be
made such as locking the basis for the classic lie algebras in favor of speed.
This is a fair trade off, but would require anyone using a different basis
to hand calculate the representations of the algebra all over again.
An alternative to solve this problem would be to use a compiled
backend that supports generics (and isn't a pain to build with python).

Rust has good python binding support through [py03](https://github.com/PyO3/pyo3)
and allows easy communication through numpy using [rust-numpy](https://github.com/PyO3/rust-numpy)
as well as numpy like api inside rust using [ndarray](https://github.com/rust-ndarray/ndarray).

## Install

```bash
pip install liesym
```

## Examples

See also example [notebook](notebooks/Example.ipynb)

<!--Autogenerated below-->
```python
import liesym as ls
from sympy import Matrix
from IPython.display import display, Markdown
from sympy.printing.str import StrPrinter
```

#### Cartan Matrix


```python
A3 = ls.A(3)
A3.cartan_matrix
```




$$\displaystyle \left[\begin{matrix}2 & -1 & 0\\\ -1 & 2 & -1\\\0 & -1 & 2\end{matrix}\right]$$



#### Positive Roots


```python
for i in A3.positive_roots():
    display(i)
```


$$\displaystyle \left[\begin{matrix}1 & 0 & 1\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}-1 & 1 & 1\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}1 & 1 & -1\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}-1 & 2 & -1\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}0 & -1 & 2\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}2 & -1 & 0\end{matrix}\right]$$


#### Simple Roots


```python
for i in A3.simple_roots():
    display(i)
```


$$\displaystyle \left[\begin{matrix}1 & -1 & 0 & 0\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}0 & 1 & -1 & 0\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}0 & 0 & 1 & -1\end{matrix}\right]$$


#### Fundamental Weights


```python
for i in A3.fundamental_weights(): # defaulted to orthogonal basis
    display(i)
```


$$\displaystyle \left[\begin{matrix}\frac{3}{4} & - \frac{1}{4} & - \frac{1}{4} & - \frac{1}{4}\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}\frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & - \frac{1}{2}\end{matrix}\right]$$



$$\displaystyle \left[\begin{matrix}\frac{1}{4} & \frac{1}{4} & \frac{1}{4} & - \frac{3}{4}\end{matrix}\right]$$


#### Dimension of representation
  


```python
table = """\
| Dim | Irrep Name | Rep (Omega) |
| :-: | :-: | :-: |
"""
for i in A3.fundamental_weights(basis="omega"):
    table += f"""\
| {A3.dim(i)} | $${A3.dim_name(i)}$$  | $${i.table(StrPrinter())}$$|
"""
Markdown(table)
```




| Dim | Irrep Name | Rep (Omega) |
| :-: | :-: | :-: |
| 4 | $$4$$  | $$[1, 0, 0]$$|
| 6 | $$6$$  | $$[0, 1, 0]$$|
| 4 | $$\bar{4}$$  | $$[0, 0, 1]$$|




#### Name of rep

Commonly in literature (especially physics), names of the reps are the dimension rather than the matrix rep.


```python
A3.dim_name(Matrix([[0, 0, 1]]))
```




$$\displaystyle \bar{4}$$




```python
A3.irrep_lookup(r"\bar{4}")
```




$$\displaystyle \left[\begin{matrix}0 & 0 & 1\end{matrix}\right]$$



#### Tensor product decomps

The decomp of irreps from a product of irreps


```python
results = A3.tensor_product_decomposition([
    Matrix([[1,0,0]]),
    Matrix([[1,0,0]]),
])

table = """\
| Rep | Dim name |
| :-: | :-: |
"""
for i in results:
    table += f"""\
| $${i.table(StrPrinter())}$$ | $${A3.dim_name(i)}$$ |  
"""
Markdown(table)
```




| Rep | Dim name |
| :-: | :-: |
| $$[0, 1, 0]$$ | $$6$$ |  
| $$[2, 0, 0]$$ | $$\bar{10}$$ |  




#### Lie Groups

Currently supports SU(N), SO(N), Sp(N)


```python
su2 = ls.SU(2)
su2.generators()
```




    [Matrix([
     [  0, 1/2],
     [1/2,   0]]),
     Matrix([
     [  0, -I/2],
     [I/2,    0]]),
     Matrix([
     [1/2,    0],
     [  0, -1/2]])]




```python
# cartan generators
su2.generators(cartan_only=True)
```




    [Matrix([
     [1/2,    0],
     [  0, -1/2]])]



Structure constants. SU(2) structure constants are $e_{ijk}$


```python
su2.structure_constants()
```




$$\displaystyle \left[\begin{matrix}\left[\begin{matrix}0 & 0 & 0\\\0 & 0 & 1\\\0 & -1 & 0\end{matrix}\right] & \left[\begin{matrix}0 & 0 & -1\\\0 & 0 & 0\\\1 & 0 & 0\end{matrix}\right] & \left[\begin{matrix}0 & 1 & 0\\\ -1 & 0 & 0\\\0 & 0 & 0\end{matrix}\right]\end{matrix}\right]$$




```python
A1 = ls.A(1)
for x in A1.simple_roots(basis="omega"):
    display(x)
```


$$\displaystyle \left[\begin{matrix}2\end{matrix}\right]$$


Quadratic Casimir


```python
s = ls.Sp(6)
r = s.algebra.fundamental_weights()[0]
s.quadratic_casimir(r)
```




$$\displaystyle \frac{7}{2}$$


