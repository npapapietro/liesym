use crate::debug::debug_on;
use crate::matrix_methods::{all_pos, reflect_weights, reflection_matrix};
use crate::utils::{to_rational_list, to_rational_matrix, Array2R};

use ndarray::Array;
use num::rational::Ratio;
use numpy::PyReadonlyArray3;
use std::iter::FromIterator;

pub struct OrbitMethods {
    pub simple_roots: Vec<Array2R>,
    pub omega_inv: Array2R,
    pub omega: Array2R,
    pub cartan_inv: Array2R,
    pub cocartan_t: Array2R,
    pub n_roots: usize,
    pub rank: usize,
}

impl OrbitMethods {
    /// Returns an instance of Orbitmethods. Since this module in rust doesn't not take inverses of rational matrices, we pass them
    /// in from python.
    ///
    /// # Arguments
    /// * `simple_roots` - An array of shape (N_roots, Dim_roots, 2), where the two counts the numerator and denominator of a rational number
    /// * `omega_inv` - An array of shape (Rank, Rank, 2), where the two counts the numerator and denominator of a rational number.
    /// * `cartan_inv` - An array of shape (Rank, Rank, 2), where the two counts the numerator and denominator of a rational number.
    /// * `n_roots` - Number of roots in the algebra.
    pub fn new(
        simple_roots: PyReadonlyArray3<i64>,
        omega_inv: PyReadonlyArray3<i64>,
        omega: PyReadonlyArray3<i64>,
        cartan_inv: PyReadonlyArray3<i64>,
        cocartan_t: PyReadonlyArray3<i64>,
        n_roots: usize,
        rank: usize,
    ) -> OrbitMethods {
        if debug_on() {
            println!("Creating Orbit Methods");
        }
        let simple_roots = to_rational_list(simple_roots);

        let omega_inv = to_rational_matrix(omega_inv);

        let omega = to_rational_matrix(omega);

        let cartan_inv = to_rational_matrix(cartan_inv);

        let cocartan_t = to_rational_matrix(cocartan_t);

        OrbitMethods {
            simple_roots: simple_roots,
            omega_inv: omega_inv,
            omega: omega,
            cartan_inv: cartan_inv,
            cocartan_t: cocartan_t,
            n_roots: n_roots,
            rank: rank,
        }
    }

    /// Returns the orbit for weight
    ///
    /// # Arguments
    /// * `weight` - The weight to generate the orbit about.
    ///
    pub fn orbit(&self, weight: Array2R) -> Vec<Array2R> {
        if debug_on() {
            println!("Starting orbit calculated");
        }
        let mut full_orbit = self.full_orbit(self.to_dominant(weight), None);
        let rot = self.omega_inv.dot(&self.cartan_inv);

        // Sorting by rotating and sum value
        full_orbit.sort_by(|a, b| self.root_level(a, &rot).cmp(&self.root_level(b, &rot)));

        full_orbit
    }

    /// Returns the orbit for weight stabilized around some simple roots.
    ///
    /// # Arguments
    /// * `weight` - The weight to generate the orbit about.
    /// * `stablizers` - A vector of indexes corresponding to the simple roots.
    ///
    pub fn stable_orbit(&self, weight: Array2R, stablizers: Vec<usize>) -> Vec<Array2R> {
        let mut full_orbit = self.full_orbit(self.to_dominant(weight), Some(stablizers));
        let rot = self.omega_inv.dot(&self.cartan_inv);
        full_orbit.sort_by(|a, b| self.root_level(a, &rot).cmp(&self.root_level(b, &rot)));

        full_orbit
    }

    /// Returns the reflection matrices generated by the simple roots
    pub fn reflection_matrices(&self) -> Vec<Array2R> {
        self.simple_roots.iter().map(reflection_matrix).collect()
    }

    /// Returns the reflected weights/roots by stabilizers
    ///
    /// # Arguments
    /// * `weights` - Vec of weights to generate reflections about
    /// * `stabilizers` - Optional list of indexes matching simple root generated reflection matrices.
    pub fn reflect_weights(
        &self,
        weights: Vec<Array2R>,
        stablizers: Option<Vec<usize>>,
    ) -> Vec<Array2R> {
        let reflection_matrices = self.reflection_matrices();
        let ref_mats = match stablizers {
            Some(x) => x.iter().map(|i| reflection_matrices[*i].clone()).collect(),
            None => reflection_matrices,
        };

        reflect_weights(&weights, &ref_mats)
    }

    pub fn root_system(&self) -> Vec<Array2R> {
        let mut roots = Vec::new();
        for i in self.simple_roots.iter() {
            let orbit = self.orbit(i.clone());
            roots.extend(orbit.iter().cloned());
        }

        roots = roots.iter().map(|x| x.dot(&self.cocartan_t)).collect();

        for _ in 0..self.rank {
            roots.push(Array::zeros((1, self.rank)));
        }
        let rot = self.omega_inv.dot(&self.cartan_inv);
        roots.sort_by(|a, b| {
            self.root_level(a, &rot)
                .cmp(&self.root_level(b, &rot))
                .then(Vec::from_iter(a.iter().clone()).cmp(&Vec::from_iter(b.iter().clone())))
        });

        roots
    }

    /// Integer root level for a weight `x`
    fn root_level<'a>(&self, x: &'a Array2R, rot: &'a Array2R) -> Ratio<i64> {
        x.dot(&self.cartan_inv).dot(rot).sum()
    }

    /// Returns a list of either count 1 or 0 with the dominant weight
    /// if it exists in the list
    fn find_dom<'a>(&self, arrays: &'a Vec<Array2R>) -> Vec<Array2R> {
        for i in arrays.iter() {
            if all_pos(&i.dot(&self.omega_inv)) {
                return vec![i.clone()];
            }
        }
        Vec::new()
    }

    /// Returns the dominant weight by rotating across
    /// weyl chambers
    fn to_dominant(&self, weight: Array2R) -> Array2R {
        let mut orbits = vec![weight];
        loop {
            orbits = self.reflect_weights(orbits, None);
            let dom = self.find_dom(&orbits);
            if dom.len() > 0 {
                break (&dom[0]).clone();
            }
        }
    }

    /// Returns the full orbit with optional stabilization for the weight
    fn full_orbit(&self, weight: Array2R, stablizers: Option<Vec<usize>>) -> Vec<Array2R> {
        let mut orbit = vec![weight];
        for _ in 0..self.n_roots {
            orbit = self.reflect_weights(orbit, stablizers.clone());
        }
        orbit
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use ndarray::{array, Array, Dimension};

    fn to_ratio<D>(x: Array<i64, D>) -> Array<Ratio<i64>, D>
    where
        D: Dimension,
    {
        x.mapv(|x| Ratio::new(x, 1))
    }

    #[test]
    fn test_orbit() {
        let half: num::rational::Ratio<i64> = Ratio::new(1, 2);

        let simple_roots = vec![
            to_ratio(array![[1, -1, 0, 0]]),
            to_ratio(array![[0, 1, -1, 0]]),
            to_ratio(array![[0, 0, 1, 0]]),
            array![[-half, -half, -half, -half]],
        ];
        let cartan_inv = to_ratio(array![
            [2, 3, 4, 2],
            [3, 6, 8, 4],
            [2, 4, 6, 3],
            [1, 2, 3, 2]
        ]);
        let omega_inv = to_ratio(array![
            [1, 0, 0, -1],
            [-1, 1, 0, -1],
            [0, -1, 2, -1],
            [0, 0, 0, -1]
        ]);
        let weight = to_ratio(array![[1, -1, 0, 0]]);

        let orb = OrbitMethods {
            simple_roots: simple_roots,
            cartan_inv: cartan_inv,
            omega_inv: omega_inv,
            omega: Array2R::zeros((1, 1)),
            cocartan_t: Array2R::zeros((1, 1)),
            n_roots: 48,
            rank: 4,
        };

        let res = orb.orbit(weight);
        assert_eq!(res.len(), 24);
    }

    #[test]
    fn test_orbit_to_dom() {
        let half: num::rational::Ratio<i64> = Ratio::new(1, 2);

        let simple_roots = vec![
            to_ratio(array![[1, -1, 0, 0]]),
            to_ratio(array![[0, 1, -1, 0]]),
            to_ratio(array![[0, 0, 1, 0]]),
            array![[-half, -half, -half, -half]],
        ];
        let cartan_inv = to_ratio(array![
            [2, 3, 4, 2],
            [3, 6, 8, 4],
            [2, 4, 6, 3],
            [1, 2, 3, 2]
        ]);
        let omega_inv = to_ratio(array![
            [1, 0, 0, -1],
            [-1, 1, 0, -1],
            [0, -1, 2, -1],
            [0, 0, 0, -1]
        ]);

        let orb = OrbitMethods {
            simple_roots: simple_roots,
            cartan_inv: cartan_inv,
            omega_inv: omega_inv,
            omega: Array2R::zeros((1, 1)),
            cocartan_t: Array2R::zeros((1, 1)),
            n_roots: 48,
            rank: 4,
        };

        let non_dom = to_ratio(array![[0, 1, 1, 0i64]]);
        let result = orb.to_dominant(non_dom);

        assert_eq!(result, to_ratio(array![[1, 0, 0, -1i64]]));
    }
}
